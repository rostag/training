<h3>Інструкції</h3>
<p><strong>Інструкції-вирази</strong></p>
<p>Найпростіший вид інструкцій в JavaScript - це вирази, що призводять до деяких динамічних дій. Основна категорія інструкцій-виразів - це інструкції присвоювання. Наприклад:</p>
<pre>s = 'Hello ' + name;
i *= 3;
counter++;
delete o.x;</pre>
<p>Кожен рядок у цих прикладах завершується крапкою з комою.</p>
<p>Складні інструкції - в чистому вигляді практично не використовуються.</p>
<p>У JavaScript є також можливість об'єднання декількох інструкцій в одну інструкцію або в блок інструкцій. Це робиться простим укладанням будь-якої кількості інструкцій у фігурні дужки. Таким чином, наступні рядки розглядаються як одна інструкція і можуть використовуватися скрізь, де інтерпретатор JavaScript вимагає наявності єдиної інструкції:</p>
<pre>{
&nbsp;&nbsp;x = Math.PI;
&nbsp;&nbsp;cx = Math.cos(x);
&nbsp;&nbsp;alert("cos(" + x + ") = " + cx);
}
</pre>
<p>Зверніть увагу, що хоча блок інструкцій діє як одна інструкція, він не завершується крапкою з комою. Окремі інструкції всередині блоку завершуються крапкою з комою, однак сам блок - ні.</p>
<ul>
    <li>
        <strong>Інструкція if / else if</strong>
        <p>
            Інструкція if - це базова керуюча інструкція, що дозволяє інтерпретатору JavaScript приймати рішення або, точніше, виконувати інструкції в залежності від виконання:</p>
        <pre>if (вираз)
&nbsp;&nbsp;інструкція</pre>
        <p>Конструкція else виконується тоді, коли вираз дорівнює false. Її синтаксис:</p>
        <pre>if (выражение)
&nbsp;&nbsp;інструкція1
else
&nbsp;&nbsp;інструкція2</pre>
        <h4>Інструкція else if</h4>
        <pre>
if (n == 1) {} // Виконуємо блок коду 1
else if (n == 2) {} // Виконуємо блок коду 2
else if (n == 3) {} // Виконуємо блок коду 3
else {} // Якщо всі інші умови else не виконуються, виконуємо блок 4</pre>
    </li>
    <li>
        <strong>Інструкція switch</strong>
        <p>Синтаксис:</p>
        <pre>switch(n) {
		
		&nbsp;&nbsp;case 1: // Виконується, якщо n == 1
		
		&nbsp;&nbsp;&nbsp;&nbsp;// Виконуємо блок коду 1
		
		&nbsp;&nbsp;&nbsp;&nbsp;break; // Тут зупиняємося
		
		&nbsp;&nbsp;case 2: // Виконується, якщо n == 2
		
		&nbsp;&nbsp;&nbsp;&nbsp;// Виконуємо блок коду 2.
		
		&nbsp;&nbsp;&nbsp;&nbsp;break; // Тут зупиняємося
		
		&nbsp;&nbsp;case 3: // Виконується, якщо n == 3
		
		&nbsp;&nbsp;&nbsp;&nbsp;// Виконуємо блок коду 3.
		
		&nbsp;&nbsp;&nbsp;&nbsp;break; // Тут зупиняємося
		
		&nbsp;&nbsp;default: // Якщо все інше не підходить...
		
		&nbsp;&nbsp;&nbsp;&nbsp;// Виконуємо блок коду 4.
		
		&nbsp;&nbsp;&nbsp;&nbsp;break; // Тут зупиняємося
		
		}</pre>
        <p>Зверніть увагу на ключове слово break в кінці кожного блоку case. Інструкція break призводить до передачі управління в кінець інструкції switch або циклу. Конструкції case в інструкції switch задають тільки початкову точку виконуваного коду, але не задають ніяких кінцевих точок. У разі відсутності інструкцій break інструкція switch починає виконання блоку коду з мітки case, відповідної значенню виразу, і продовжує виконання до тих пір, поки не дійде до кінця блоку.</p>
        <p>Якщо мітка default: відсутня, то інструкція switch повністю пропускається. Зверніть увагу, що в попередніх прикладах мітка default: вказана в кінці тіла інструкції switch після всіх міток case.</p>
    </li>
    <li>
        <strong>Інструкція while</strong>
        <p>Так само як інструкція if є базовою керуючої інструкцією, що дозволяє інтерпретатору JavaScript приймати рішення і виконувати повторювані дії. Вона має наступний синтаксис: </p>
        <pre>while (вираз)
інструкція</pre>
        <p>
            Інструкція while починає роботу з обчислення виразу. Якщо результатом є false, інтерпретатор JavaScript переходить до наступної інструкції програми, а якщо true, то виконується інструкція, що утворює тіло циклу, і вираз обчислюється знову. І знову, якщо значення дорівнює false, інтерпретатор JavaScript переходить до наступної інструкції програми, в іншому випадку він виконує інструкцію знову. Цикл триває, поки вираз не стане рівним false, тоді інструкція while завершить роботу і JavaScript піде далі. За допомогою синтаксису <code>while(true)</code> можна створити безкінечный цикл.</p>
    </li>
    <li>
        <strong>Цикл do/while</strong>
        <p>Цикл do/while в чомусь схожий на цикл while, за винятком того, що вираз циклу перевіряється в кінці, а не на початку циклу. Це означає, що тіло циклу завжди виповнюється хоча б один раз. Синтаксис:</p>
        <pre>do
інструкція
while (вираз);</pre>
    </li>
    <li>
        <strong>Інструкція for</strong>
        <p>Синтаксис циклу for: </p>
        <pre>for(ініціалізація; перевірка; інкремент)
		інструкція</pre>
        <p>
            Ініціалізація, перевірка і оновлення - це три ключові операції, виконуваних зі змінною циклу; інструкція for робить ці три кроки явною частиною синтаксису циклу. Це особливо полегшує розуміння дій, виконуваних циклом for, і запобігає таких помилок, як пропуск ініціалізації або збільшення змінної циклу.</p>
    </li>
    <li>
        <strong>Інструкція for/in</strong>
        <p>Синтаксис: </p>
        <pre>for (змінна in object)
		інструкція</pre>
        <p>
            Тут змінна повинна бути або ім'ям змінної, або інструкцією var з оголошенням змінної, або елементом масиву, або властивістю об'єкта (тобто має бути чимось, що може перебувати лівій частині виразу присвоювання). Параметр <code>object</code> — це ім'я об'єкта або вираз, результатом якого є об'єкт. А інструкція - це одна або блок інструкцій, що утворюють тіло циклу.</p>
    </li>
    <li>
        <strong>Інструкція break</strong>
        <p>Інструкція break призводить до негайного виходу з самого внутрішнього циклу або iнструкції switch. У циклах вона зазвичай використовується для передчасного виходу в тих випадках, коли за якої-небудь причини відпала потреба доводити виконання циклу до кінця. Коли в циклі є складні умови виходу, то часто простіше реалізувати деякі з цих умов за допомогою інструкції переривання, а не намагатися включити їх усі в один вираз циклу.</p>
        <pre>
for(i = 0; i &lt; a.length; i++) {
&nbsp;&nbsp;if (a[i] == target)
&nbsp;&nbsp;break;
}
</pre>
    </li>
    <li>
        <strong>Інструкція continue</strong>
        <p>Інструкція continue схожа з інструкцією break. Однак замість виходу з циклу continue запускає нову ітерацію циклу, перериваючи лише поточну ітерацію, а не увесь цикл.</p>
    </li>
    <li>
        <strong>Інструкція var</strong>
        <p>Інструкція var дозволяє явно оголосити одну або декілька змінних. Інструкція має наступний синтаксис: </p>
        <pre>var var_1 [ = value_1] [ ,..., var_n [= value_n]]</pre>
        <p>За ключовим словом var через кому іде список змінних, що оголошуються; кожна змінна в списку може мати спеціальний вираз-ініціалізатор, який вказує її початкове значення. Наприклад:</p>
        <pre>var i;
var j = 0;
var p, q;
var greeting = "hello" + name;
var x = 2.34, y = Math.cos(0.75), r, theta;
</pre>
        <p>
            Інструкція вар визначає кожну з перелічених змінних шляхом створення властивості з цим ім'ям в об'єкті виклику функції, в якій вона знаходиться, або в глобальному об'єкті, якщо оголошення знаходиться не в тілі функції. Властивість або властивості, що створюються за допомогою інструкції var, не можуть бути видалені оператором delete.</p>
    </li>
    <li>
        <strong>Інструкція function</strong>
        <p>Інструкція function в JavaScript визначає функцію, має такий синтаксис: </p>
        <pre>function ім'я_функції([арг1 [,арг2 [..., аргn]]]) {
&nbsp;&nbsp;інструкції
}</pre>
        <p>
            Тут ім'я_функції - має бути ідентифікатором, а не рядком або виразом. За ім'ям функції іде укладений в дужки список імен аргументів, розділених комами. Ці ідентифікатори можуть використовуватися в тілі функції для посилання на значення аргументів, переданих при виклику функції.
            <p></p>
            Тіло функції складається з довільного числа JavaScript-інструкцій, укладених у фігурні дужки. Ці інструкції не виконуються при визначенні функції. Вони компілюються і зв'язуються з новим об'єктом функції для виконання при її виклику за допомогою оператора виклику (). Зверніть увагу, що фігурні дужки - це обов'язкова частина інструкції функції. На відміну від блоків інструкцій в циклах, а і інших конструкціях, тіло функції вимагає фігурних дужок, навіть якщо воно складається лише з однієї інструкції (у нових, стрілочних функціях, можна опускати й дужки).</p>
    </li>
    <li>
        <strong>Інструкція return</strong>
        <p>Інструкція return може розташовуватися тільки в тілі функції. Присутність її в будь-якому іншому місці є синтаксичної помилкою. Коли виконується інструкція повернення, обчислюється вираз і його значення повертається в якості значення функції. Інструкція return припиняє виконання функції, навіть якщо в тілі функції залишилися інші інструкції. Інструкція повернення використовується для повернення значення таким чином:</p>
        <pre>
function square(x) { return x*x; }</pre>
        <p>Інструкція return може також використовуватися без виразу, тоді вона просто перериває виконання функції, не повертаючи значення. Якщо у функції виконується інструкція повернення без виразу, або якщо виконання функції припиняється через досягнення кінця тіла функції, то значення виразу виклику функції є невизначеним (undefined).</p>
    </li>
    <li>
        <strong>Інструкція throw</strong>
        <p>Виняток — це сигнал, що вказує на виникнення якої-небудь виняткової ситуації або помилки. Генерація виняту (throw) — це спосіб повідомити про таку помилку або виняткову ситуацію. Перехопити виняток (catch) — значить обробити його, тобто зробити дії, необхідні або підходящі для відновлення після того, як щось пішло не так. У JavaScript винятки генеруються в тих випадках, коли виникає помилка часу виконання, тоді програма явно генерує його за допомогою інструкції throw. Винятки перехоплюються за допомогою інструкції try / catch / finally. Інструкція throw має наступний синтаксис:</p>
        <pre>throw вираз;</pre>
        <p>Результатом виразу може бути значення будь-якого типу. Проте зазвичай це екземпляр класу Error чи одного з його підкласів. Також буває зручно використовувати в якості вираження рядок, що містить повідомлення про помилку або числове значення, що позначає деякий код помилки. Ось приклад коду, в якому інструкція кинути застосовується для генерації виключення:
            <br />
            <pre>function factorial(x) {
&nbsp;&nbsp;// Якщо вхідний аргумент не є допустимим, генеруємо виняток!
&nbsp;&nbsp;if (x < 0) throw new Error("x не може бути негативним");
&nbsp;&nbsp;// В іншому випадку — обчислюємо значення і нормальним чином виходимо з функції
&nbsp;&nbsp;for(var f = 1; x > 1; f *= x, x--) /* пусте тіло циклу */ ;
&nbsp;&nbsp;return f;
}
</pre>
            <p>
                Коли генерується виняток, інтерпретатор JavaScript негайно перериває нормальне виконання програми і переходить до найближчого обробника переривань. У обробниках винятків використовується конструкція catch з інструкції try/catch/finally. Якщо блок коду, в якому виникло виняток, не має відповідної конструкції catch, інтерпретатор аналізує наступний зовнішній блок коду і перевіряє, чи пов'язаний з ним обробник винятків. Це продовжується до тих пір, поки обробник не буде знайдений. Якщо виняток генерується в функції, що не містить інструкції try/catch/finally, призначеної для його обробки, то виключення поширюється на код, що викликав функцію. Так Винятки поширюються по лексичній структурі методів JavaScript вгору по стеку викликів. Якщо обробник виключення так і не буде знайдений, виключення розглядається як помилка і про неї повідомляється користувачеві.</p>
    </li>
    <li>
        <strong>Інструкція try/catch/finally</strong>
        <p>Інструкція try/catch/finally реалізує механізм обробки виключень в JavaScript. Конструкція try ('спробуй') в цій інструкції просто визначає блок коду, в якому обробляються виняткові ситуації. За блоком try іде конструкція catch ('спіймай') з блоком інструкцій, що викликаються, коли десь в блоці try виникає виняток. За конструкцією cathc іде блок finally ('нарешті'), що містить код зачистки, який гарантовано виконується незалежно від того, що відбувається в блоці try. І блок catch, і блок finally не є обов'язковими, проте після блоку try мусить обов'язково іти хоча б один з них. Блоки try, catch, finally починаються і закінчуються фігурними дужками. Це обов'язкова частина синтаксису і вона не може бути опущена, навіть якщо між ними міститься тільки одна інструкція.</p>
        <pre>try {
// ...
} catch(error) {
// ...
} finally {
// ...
}</pre>
        <p>try - зазвичай цей код без збоїв працює від початку до кінця. Але в якийсь момент в ньому може генеруватися виняток або безпосередньо за допомогою інструкції throw, або побічно через викликом методу, що генерує виняток.</p>
        <p>catch - інструкції в цьому блоці виконуються тоді і тільки тоді, коли в блоці try генерується Виняток. Ці інструкції можуть використовувати локальну змінну е, що посилається на об'єкт помилки або на інше значення, вказане в інструкції throw Цей блок може або яким-небудь чином обробити виняток, або проігнорувати його, роблячи щось інше, або заново згенерувати виключення за допомогою інструкції throw.</p>
        <p>finally - цей блок містить інструкції, які виконуються завжди, незалежно від того, що відбулося в блоці try. Вони виконуються, якщо блок try завершений одним з цих способів:</p>
        <ol>
            <li>
                нормальним чином, досягнувши кінця блоку
            </li>
            <li>
                із-за інструкції break, continue або return
            </li>
            <li>
                з винятком, обробленим у блоці catch
            </li>
            <li>
                з неперехваченим винятком, що продовжує своє поширення на більш високі рівні програми
            </li>
        </ol>
    </li>
</ul>
