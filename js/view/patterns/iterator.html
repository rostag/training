<h3>The Iterator Pattern</h3>
<p>Шаблон ітератора застосовується, коли є об'єкт, що містить сукупність даних. Ці дані можуть зберігатися у вигляді складної структури, а вам необхідно забезпечити зручний доступ до кожного елементу цієї структури. Користувачі вашого об'єкта не зобов'язані знати, як організовані ваші дані, - їм необхідний доступ до окремих елементів.</p>
<p>Об'єкт, який реалізує шаблон ітератора, повинен надати метод next(). При наступному зверненні метод next() повинен повернути наступний елемент, і тільки вам вирішувати, що означає поняття «наступний» для вашої конкретної структури даних.</p>
<p>Тобто патерн дозволяє перебирати елементи колекції, не знаючи, як реалізована колекція. Застосування патерну дозволяє передати відповідальність перебору елементів від об'єкта колекції об'єкту ітератора. Ця обставина не тільки спрощує інтерфейс, але і позбавляє колекцію від сторонніх обов'язків (її головним завданням є управління об'єктами, а не перебір. </p>
<p>Застосування: ідея полягає в тому, щоб покласти відповідальність за обхід складеного об'єкта на окремий об'єкт-ітератор. Іншими словами, у вас може бути об'єкт класу List і об'єкт класу ListIterator. Клас List відповідає за роботу з елементами списку (реалізує методи add, remove, count), а клас ListIterator відповідає за обхід списку (реалізує методи next, previous, getCurrentItem, isDone). Якщо ми винесемо алгоритм обходу структури за межі самої структури, тоді ми зможемо додавати нові алгоритми обходу, при цьому не змінюючи саму структуру (клас List). Наприклад, для того, щоб додати можливість обходу парних і непарних елементів структури, ми створюємо 2 класу: EvenListIterator і OddListIterator.</p>
