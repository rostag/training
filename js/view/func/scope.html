<h3>Лексична область видимості функції</h3>
<p>Функції в JavaScript мають не динамічну, а лексичну область видимості. Це означає, що вони виконуються в області видимості,
	яка була створена на момент визначення функції, а не на момент її виконання. У момент визначення функції поточний ланцюжок
	областей видимості зберігається і стає частиною внутрішнього стану функції. На верхньому рівні область видимості просто
	складається з глобального об'єкта, і про лексичну область видимості годі й казати. Однак коли оголошується вкладена функція,
	її ланцюжок областей видимості включає і функцію, що її охоплює. Це означає, що вкладена функція має можливість доступу
	до всіх аргументів і локальних змінних охоплюючої її функції.
</p>
<p>Іноді буває зручно створити функцію тільки заради того, щоб отримати об'єкт виклику, який діє як тимчасовий простір імен,
	де можна визначати змінні і властивості, не турбуючись про можливі конфлікти з глобальним простором імен..</p>
<p>
	<code>var global = 'Global scope';</code>
	<br />
	<code>function funcA(){</code>
	<br />
	<code>&nbsp;&nbsp;var local = 'Local scope';</code>
	<br />
	<code>&nbsp;&nbsp;function funcB(){</code>
	<br />
	<code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(global);</code>
	<br />
	<code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(local);</code>
	<br />
	<code>&nbsp;&nbsp;}</code>
	<br />
	<code>}</code>
</p>
<p>Нерідко можна зіткнутися з неприємним наслідком від наявності одного єдиного глобального простору імен - проблеми з перекриттям
	імен змінних. В JavaScript цю проблему легко уникнути, використовуючи анонімні обгортки.</p>
<p>
	<code>(function(){</code>
	<br />
	<code>&nbsp;&nbsp; // isolated scope</code>
	<br />
	<code>})();</code>
</p>
<h2>Інші способи створення анонімної обгортки</h2>
<p>
	<code>+function(){}();</code>
	<br />
	<code>(function(){}());</code>
</p>
<p>Рекомендується завжди використовувати анонімну обгортку для того, щоб ваш код існував у власному просторі імен. Це не тільки
	захищає код від збігів імен, але і дозволяє створювати модульні програми.</p>