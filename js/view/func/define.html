<p>Самый распространенный способ определения функции –
использование инструкции <code>function</code>. Она состоит из ключевого слова function, за
которым следуют: имя функции, заключенный в круглые скобки необязательный список имен параметров,
разделенных запятыми, тело функции, заключенные в фигурные скобки.</p>
<p><code>function name(a, b){/* code */}</code></p>
<p>Помимо этого существует возможность создания
функций с помощью конструктора Function():</p>
<p><code>var name = new Function('a, b', '/* code */');</code><br/><code>var name = new Function('a', 'b', '/* code */');</code></p>
<p>Конструктор Function() позволяет динамически создавать и компилировать
функции во время исполнения программы.</p>
<p>Применение конструктора Function() считается далеко не лучшим ре-
шением (аналогично использованию функции eval()), потому что про-
граммный код передается в виде строки и интерпретируется. Кроме
того, такой программный код сложнее писать (и читать) из-за необхо-
димости экранировать кавычки и предпринимать дополнительные
усилия для оформления внутри функции отступов, позволяющих по-
высить удобочитаемость.</p>
<p>Функции также могут содержать или не содержать инструкцию return. Она прекращает выполнение функции
и возвращает значение указанного в ней выражения либо при отсутствии выражения инструкция возвращает значение undefined. Если функция не содержит инструкцию return, она просто выполняет все
инструкции в своем теле и возвращает неопределенное значение (undefined).</p>
<p><code>function name(){ var a = 1; }</code></p>
<p><code>function name(){ var a = 1; return a;}</code></p>
<p>Будучи один раз определенной, функция может вызываться с помощью оператора <code>()</code>, скобки указываются после имени
функции, а необязательный список значений (или выражений) аргументов указывается в скобках через запятую.</p>
<p>При вызове функции вычисляются все выражения, указанные между скобками,
и полученные значения используются в качестве аргументов функции. Эти значения присваиваются параметрам, имена которых перечислены в определении
функции, и функция работает с ними, ссылаясь на эти параметры по указанным
именам. Обратите внимание: эти переменные-параметры определены, только
пока выполняется функция; они не сохраняются после завершения ее работы.</p>
<p><code>foo(a+b, c);</code></p>
<p>Обратите внимание: Javascript не проверяет тип параметров функции, а также не проверяет,
правильное ли количество параметров передано функции. Если аргументов
больше, чем требуется функции, то дополнительные значения просто игнорируются. Если аргументов меньше, то отсутствующим присваивается значение undefined.</p>
<h3>Aнонимные функции</h3>
<p>Функциональные литералы = неименованные функции-выражения = анонимные функции</p>
<p>Используется как вираз, а не как инструкция, и ему не требуется имя функции. Следующие две строки кода определяют две более или менее идентичные
функции с помощью инструкции function и функционального литерала</p>
<p><code>function f(x) { return x*x; } // инструкция function</code><br/><code>var f = function(x) { return x*x; }; // функциональный литерал</code></p>
<p>Подходит для
функций, которые вызываются только один раз и не должны иметь имени. Например, функция, определенная с помощью выражения функционального литерала, может быть сохранена в переменной, передана другой функции или даже
вызвана непосредственно</p>
<p>
	<code>f[0] = function(x) { return x*x; };</code>
	<br />
	<code>a.sort(function(a,b){return a-b;});</code>
	<br />
	<code>var tensquared = (function(x) {return x*x;})(10);</code>
</p>
<h4>Подъем функции (Hoisting)</h4>
<p>Объявления всех переменных, независимо от того,
в каком месте внутри функции они находятся, на этапе интерпретации
как бы «поднимаются» в начало функции. То же относится и к функци-
ям. Но для функций-объявлений
вместе с именем функции «поднимается» и ее определение, а не только
имя.</p>
<p><code>// инструкция function</code></p>
<p>
	<code>foo();</code>
	<br />
	<code>function foo() {}</code>
</p>
<p><code>// function как вираз</code></p>
<p>
	<code>foo; // 'undefined'</code>
	<br />
	<code>foo(); // вызовет TypeError</code>
	<br />
	<code>var foo = function() { return 'ololo	'};</code>
	<br />
	<code>foo();</code>
</p>
