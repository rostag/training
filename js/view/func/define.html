<p>Найпоширеніший спосіб визначення функції - використання інструкції
	<code>function</code>. Вона складається з ключового слова function, за яким ідуть: ім'я функції, взятий у круглі дужки необов'язковий
	список імен параметрів, розділених комами, і тіло функції у фігурних дужках.</p>

<p>
	<code>function name(a, b){/* code */}</code>
</p>
<p>Крім цього, існує можливість створення функцій за допомогою конструктора Function():</p>
<p>
	<code>var name = new Function('a, b', '/* code */');</code>
	<br/>
	<code>var name = new Function('a', 'b', '/* code */');</code>
</p>
<p>Конструктор Function() дозволяє динамічно створювати і компілювати функції під час виконання програми.</p>
<p>Застосування конструктора Function () вважається не найкращим рішенням (аналогічно використанню функції eval()), тому що
	програмний код передається у вигляді рядка і інтерпретується. Крім того, такий програмний код складніше писати (і читати)
	через необхідність екранувати лапки і вживати додаткових зусиль для оформлення всередині функції відступів, щоб підвищити
	читабельність.
</p>
<p>Функції також можуть містити або не містити інструкцію return. Вона припиняє виконання функції і повертає значення зазначеного
	в ній виразу, або, при відсутності виразу, інструкція повертає значення undefined. Якщо функція не містить інструкцію return,
	вона просто виконує всі інструкції в своєму тілі і повертає невизначене значення (undefined).</p>
<p>
	<code>function name(){ var a = 1; }</code>
</p>
<p>
	<code>function name(){ var a = 1; return a;}</code>
</p>
<p>Будучи один раз певної, функція може викликатися за допомогою оператора
	<code>()</code>, дужки вказуються після імені функції, а необов'язковий список значень (або виразів) аргументів вказується в дужках
	через кому.</p>
<p>При виконанні функції обчислюються всі вирази, зазначені між дужками, і отримані значення використовуються як аргументи функції.
	Ці значення присвоюються параметрам, імена яких перераховані у визначенні функції, і функція працює з ними, посилаючись
	на ці параметри за вказаними іменами. Зверніть увагу: ці змінні-параметри визначені, тільки поки виконується функція; вони
	не зберігаються після завершення її роботи.</p>
<p>
	<code>foo(a+b, c);</code>
</p>
<p>Зверніть увагу: Javascript не перевіряє тип параметрів функції, а також не перевіряє, чи правильну кількість параметрів передано.
	Якщо аргументів більше, ніж потрібно функції, то додаткові значення просто ігноруються. Якщо аргументів менше, то відсутнім
	присвоюється значення undefined.</p>

<h3>Aнонімні функции</h3>
<p>Функціональні літерали = неіменовані функції-вирази = анонімні функції</p>
<p>Використовуються як вирази, а не як інструкції, і йому не потребують ім'я функції. Наступні два рядки визначають дві більш-менш
	ідентичні функції за допомогою інструкції function і функціонального літералу:</p>
<p>
	<code>function f(x) { return x*x; } // інструкція function</code>
	<br/>
	<code>var f = function(x) { return x*x; }; // функціональний літерал</code>
</p>
<p>Підходить для функцій, які викликаються тільки один раз і не повинні мати імені. Наприклад, функція, визначена за допомогою
	виразу функціонального літералу, може бути збережена в змінній, передана іншій функції, або навіть викликана безпосередньо.</p>
<p>
	<code>f[0] = function(x) { return x*x; };</code>
	<br />
	<code>a.sort(function(a,b){return a-b;});</code>
	<br />
	<code>var tensquared = (function(x) {return x*x;})(10);</code>
</p>
<h4>Підйом функції (Hoisting)</h4>
<p>Оголошення всіх змінних, незалежно від того, в якому місці всередині функції вони знаходяться, на етапі інтерпретації неначе
	«піднімаються» в початок функції. Те саме можна сказати і про функції. Але для функцій-оголошень разом з ім'ям функції «піднімається»
	і її визначення, а не тільки ім'я.
</p>
<p>
	<code>// інструкція function</code>
</p>
<p>
	<code>foo();</code>
	<br />
	<code>function foo() {}</code>
</p>
<p>
	<code>// function як вираз</code>
</p>
<p>
	<code>foo; // 'undefined'</code>
	<br />
	<code>foo(); // викличе TypeError</code>
	<br />
	<code>var foo = function() { return 'ololo '};</code>
	<br />
	<code>foo();</code>
</p>