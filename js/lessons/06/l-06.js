/*
 * Вивчення JavaScript.
 * Урок 6. Теми:
 *  - Оператори (завершення)
 *	- Оптимізація коду: від базової до екстремальної
 *  - Рефакторинг (базове поняття)
 * Щоб завантажити урок у Шелл: Core.Load('../../lessons/06/l-06.js');
 */

'use strict';

Core.Print('\nLesson 06 - Start');

//
// Оператори - завершення
//

// Оператори розріняють за кількістю операндів:

// Унарні: мають один операнд, наприклад, унарний мінус у виразі -1
// Бінарні: мають два операнди, наприклад, бінарний мінус у виразі 1+1
// Тернарні: мають три операнди, приклад наводиться нижче.

//
// Оператор коми: ,
//

// Оператор «кома» (,) дуже простий.
// Він обчислює свій лівий операнд, обчислює свій правий операнд і повертає
// значення правого операнда. Цей рядок: i=0, j=1, k=2; повертає значення 2.

// На практиці кому часто використовують для стислішого оголошення змінних.
// Нижче, приклади 1. та 2. дають однаковий результат:

// 1.
var i = 0,
    j = 1,
    k = 2;

// 2.
var i = 0;
var j = 1;
var k = 2;

//
// Оператори доступу до масивів та об'єктів: []
//

// Можна звертатися до елементів масиву за допомогою квадратних дужок ([]),
// а до елементів об'єкта - за допомогою крапки (.).
// І квадратні дужки, і крапка розглядаються в JavaScript як оператори.

var arr = [1, 2, 3, 5];
var myObject = { child: { id: 1 }, parent: { id: 2 }, id: 0 };

// Приклад: отримаємо елементи масиву за допомогою []:
i = arr[0]; //1
j = arr[3]; //5

// Приклад: отримаємо властивість об'єкту за допомогою . (крапки)...

k = myObject.id;
k = myObject.child;
k = myObject.child.id;

// ... або за допомогою [], що вважається поганим тоном, але працює:
k = myObject['id'];
k = myObject['child'];
k = myObject['child']['id'];


//
// Оператор виклику функції, ()
//

// Оператор () призначений в JavaScript для виклику функцій.
// Цей оператор не має фіксованої кількості операндів.

// Перший операнд - це завжди ім'я функції або вираз,
// що посилається на функцію. За ним слідує ліва дужка
// і будь-яка кількість додаткових операндів, які можуть бути виразами,
// відокремленими один від одного комами.

// За останніми операндом іде права дужка. Оператор ()
// обчислює всі свої операнди і потім викликає функцію,
// задану першим операндом, використовуючи в якості аргументів операнди,
// що залишилися. Наприклад:

Core.Print('Welcome ' + 'name');


//
// Оператори рівності
//

//
// Рівність (==) та ідентичність (===)
//

// Оператори == та === перевіряють дві величини на збіг, керуючись двома
// різними визначеннями збігу.

// Обидва оператори приймають операнди будь-якого типу і повертають true,
// якщо їх операнди збігаються, і false, якщо вони різні.


// Оператор == відомий як оператор рівності, він перевіряє,
// чи рівні дві його операнда відповідно з менш суворим визначенням,
// що допускає перетворення типів.

i = '1' == 1; // true

// Оператор ===, відомий як оператор ідентичності, перевіряє два операнди
// на «ідентичність», керуючись суворим визначенням збіги.

i = '1' === 1; // false



//
// Нерівність (!=) та неідентичність (!==)
//

// Оператори != та !== виконують перевірки, в точності протилежні
// операторам == та ===. Оператор != повертає false, якщо два значення
// рівні один одному, і true в іншому випадку.
// Оператор неідентичности !== повертає false, якщо два значення ідентичні
// один одному, і true — в іншому випадку.



//
// Оператори порівняння
//

//
// Менше (<)
//
// Результат оператора < дорівнює true, якщо його перший операнд менший,
// ніж другий операнд; в іншому випадку він дорівнює false.

//
// Більше (>)
//
// Результат оператора > дорівнює true, якщо його перший операнд більий,
// ніж другий операнд; в іншому випадку він дорівнює false.

//
// Менше або дорівнює (<=)
//
// Результатом оператора <= є true, якщо перший операнд менше або дорівнює
// другому операнду; в іншому випадку результат дорівнює false.

//
// Більше або дорівнює (>=)
//
// Результат оператора >= дорівнює true, якщо його перший операнд більше другого
// або дорівнює йому; в іншому випадку він дорівнює false.



//
// Оператор in
//

// Оператор in вимагає, щоб лівий операнд був рядком або міг
// бути перетворений в рядок.
// Правим операндом має бути об'єкт (або масив).
// Результатом оператора буде true,
// якщо ліве значення являє собою ім'я властивості об'єкта,
// зазначеного праворуч. Наприклад:

var obj = { x: 1, y: 1 }; // Визначили об'єкт
i = 'x' in obj; // Дорівнює true


//
// Оператор instanceof
//

// Оператор instanceof повертає true, якщо об'єкт,
// зазначений ліворуч, є екземпляром класу, зазначеного праворуч;
// в протилежному випадку результатом буде false.
// В JavaScript класи об'єктів визначаються функцією-конструктором,
// що їх ініціює.

// Отже, правий операнд instanceof має бути ім'ям функції-конструктора.
// Зверніть увагу: всі об'єкти є екземплярами класу Object. Наприклад:

// Створюємо новий об'єкт за допомогою конструктора Date():
var d = new Date();

// Дасть true, бо об'єкт d був створений за допомогою функції Date():
Core.Print('d instanceof Date: ' + (d instanceof Date));



//
// Умовний оператор (?:)
//

// Умовний оператор - це єдиний тернарний оператор (з трьома операндами)
// в JavaScript, і іноді він так і називається - «тернарний оператор».

// Цей оператор зазвичай записується як ?:, хоча в текстах програм він виглядає
// інакше. Він має три операнди, перший йде перед ?, другий – між ? і :,
// третій – після :. Приклад використання:

i = 0;

// Приклади 1. та 2. дають одинаковий результат, але перший є значно стислішим:

// 1.
j = k > 1 ? 100 : 200;

// 2.
if (k > 1) {
    j = 100;
} else {
    j = 200;
}



//
// Оператор typeof
//


// Унарний оператор typeof розташовується перед єдиним операндом,
// який може мати будь-який тип. Його значення є рядком,
// що вказує тип даних операнда.

// Результатом оператора typeof буде рядок 'number', 'string' або 'boolean',
// якщо його операндом є число, рядок або логічне значення відповідно.



//
// Оператор створення об'єкта (new)
//

// Оператор new створює новий об'єкт і викликає функцію-конструктор
// для його ініціалізації.
// Це унарний оператор, що вказується перед викликом конструктора
// і має наступний синтаксис:

// new Конструктор(параметри);

// Тут конструктор - це вираз, результатом якого є функція-конструктор,
// і за ним мають розташовуватися нуль або більше аргументів,
// розділених комами і укладених вкруглі дужки.
// Як особливий випадок і тільки для оператора new JavaScript спрощує
// граматику, допускаючи відсутність дужок, якщо у функції немає аргументів.

// Ось кілька прикладів використання оператора new:
i = new Object();

// Повертає об'єкт Date, містить поточний час
i = new Date();

// Оператор new спочатку створює новий об'єкт з невизначеними властивостями,
// а потім викликає задану функцію-конструктор,
// передаючи їй зазначені аргументи,
// а також щойно створений об'єкт в якості значення ключового слова this.
// За допомогою слова this функція-конструктор може ініціювати
// новий об'єкт будь-яким необхідним чином.



//
// Оператор delete
//

// Унарний оператор delete виконує спробу видалення властивості об'єкта,
// елемента масиву або змінної, вказаних в його операнді.
// Він повертає true, якщо видалення пройшло успішно,
// і false в іншому випадку. Не всі змінні і властивості можуть
// бути видалені - деякі вбудовані властивості з базового та клієнтського
// мов JavaScript стійкі до операції видалення.
// Крім того, не можуть бути вилучені змінні,
// визначені користувачем за допомогою інструкції var.

// Визначаємо змінну; ініціюємо її як об'єкт
var o = { x: 1, y: 2 };
// Видаляємо одну з властивостей об'єкта; повертає true
delete o.x;
// Властивість не існує; повертає 'undefined'
k = typeof o.x;
// Видаляємо неіснуючу властивість; повертає true
delete o.x;
// викличе помилку виконання у строгому режимі:
// delete o; // Оголошену змінну видалити не можна; повертає false
// delete 1; // Не можна видалити ціле; повертає true



//
// Оператор void - загадковий і корисний
//

// Унарний оператор void вказується перед своїм єдиним операндом,
// тип якого може бути будь-яким.
// Дія цього оператора незвична: він відкидає значення операнда
// і повертає undefined. Найчастіше цей оператор застосовується
// на стороні клієнта в
// URL-адресу з ознакою псевдопротокола javascript:,
// де дозволяє обчислювати вираз заради його побічних дій,
// не відображаючи в броузері обчислене значення.
// Наприклад, можна використовувати оператор void в HTML-тегах:

// HTML: <a href="javascript:void(document.body.style.backgroundColor='green');">Зелений фон</a>
// HTML: <a href="javascript:void window.open();">Відкрити нове вікно</a>


//
//
//


// Розглянемо приклад оптимізації коду на функції з домашньої роботи Уроку 5.
// Завдання було таке:

// Напишіть функцію divisableByThreeOrFive, яка використовує
// оператор ділення по модулю для того, щоб визначити,
// чи ділиться число націло і на 3, i на 5, і повертає true,
// якщо це так, або false у зворотньому випадку.
// Ось ця функція:

function divisableByThreeOrFive(a) {
    var temp = false;
    if ((a % 5 === 0) && (a % 3 === 0)) {
        temp = true;
    }
    return temp;
}

// Спробуємо її оптимізуівати так, щоб стало менше коду:

// Оптимізація перша (базова): позбавляємося від непотрібної змінної temp.
// Результат: мінус один рядок коду.
function divisableByThreeOrFive(a) {
    if ((a % 5 === 0) && (a % 3 === 0)) {
        return true;
    }
    return false;
}

// Оптимізація друга (збалансована): позбавляємося від if, бо повертаємо булеан:
// Результат: мінус ще три рядки коду.
function divisableByThreeOrFive(a) {
    return (a % 5 === 0) && (a % 3 === 0);
}

// Оптимізація третя (екстремальна): скорочуємо вирази, маючи приведення типів:
// Результат: рядків менше вже не стало, але читати стало важко:
function divisableByThreeOrFive(a) {
    return !(a % 5) && !(a % 3);
}

// Висновок: оптимізація має розумні межі, за які краще не заступати.

// "Leave optimization until last"
// У екстремальному програмуванні є правило: уникайте завчасної оптимізації,
// залиште її насамкінець.  - https://en.wikipedia.org/wiki/Extreme_programming



//
// Рефакторинг (поняття)
//

// Те, що ми зробили у оптимізаціях коду, називається рефакторингом.
// Рефакторинг - це коли ви переписуєте вже працюючий код таким чином,
// щоб він став кращим (більш зрозумілим, швидшим і т.ін.),
// даючи точно той самий результат, що й до рефакторингу.


Core.Print('\nLesson 06 - End');

//
// Домашня робота:
//

Core.Print('\nLesson 06 - Homework');

Core.Print('\nTask 6.0');
// 1 бал

// Оголошено три змінні: x, y, z
// Перепишіть код так, щоб він займав один рядок, а не три.
// Підказка: оператор коми
var x = 1;
var y = 2;
var z = 3;






Core.Print('\nTask 6.1');
// 1 бал

// Маємо масив:
var primes = [1, 3, 5, 7, 11];
// Використайте оператор доступу до масиву, щоб взнати значення 2-го елементу.
// TODO: пишіть свій код тут:






Core.Print('\nTask 6.2');
// 1 бал
// Є об'єкт:
var sky = {
    sun: true,
    moon: false,
    clouds: false
};

// За допомогою оператора доступу до властивостей об'єкта (.) запишіть у
// змінну x значення властивості clouds






Core.Print('\nTask 6.3');
// 1 бал
// Є примітивна функція:

function printHello(){ Core.Print('Hello'); }

// У якому з цих випадків у консоль буде виведено 'Hello'?

// 1:
printHello();

// 2:
printHello;

// 3:
printHello.Hello;






Core.Print('\nTask 6.4');
// 1 бал
// Оператори рівності та ідентичности
// Які результати будуть у консолі для цих випадків:

// 1.
Core.Print( 1 == 1 );

// 2.
Core.Print( 1 == '1' );

// 3.
Core.Print( 1 === 1 );

// 4.
Core.Print( 1 === '1' );






Core.Print('\nTask 6.5');
// 1 бал
// Оператори не-рівності та не-ідентичности

// Які результати будуть у консолі для цих випадків:

// 1.
Core.Print( 1 != '1' );

// 2.
Core.Print( 1 !== '1' );






Core.Print('\nTask 6.6');
// 1 бал
// За допомогою оператора in перевірте, чи є у визначеному вище об'єкті sky
// властивість moon:






Core.Print('\nTask 6.7');
// 1 бал
// За допомогою оператора instanceof перевірте, чи було об'єкт sky створено
// через конструктор Object:






Core.Print('\nTask 6.8');
// 2 бали
// Напишіть будь-який вираз з тернарним оператором (?:)






Core.Print('\nTask 6.9');
// 2 бали
// За допомогою оператора typeof визначте тип змінної primes (визначена вище)






Core.Print('\nTask 6.10');
// 2 бали
// Використайте оператор створення об'єкта, щоб створити нову дату:





Core.Print('\nTask 6.11');
// 2 бали
// Видаліть із об'єкта sky властивість moon






Core.Print('\nTask 6.12');
// (3 бали)
// Напишіть функцію, яка друкує (виводить у консоль) числа від 1 до 100.
// Але замість числа, кратного трьом, друкує не саме число, а рядок "Fizz".
// Замість чисел, кратних п'яти, друкує, "Buzz".
// А замість чисел, кратних і трьом, і п'ятьом, друкує "FizzBuzz".
// TODO: пишіть свій код тут:

Core.Print('\nLesson 06 - Homework End');
