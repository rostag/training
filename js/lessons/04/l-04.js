/** 
 * Вивчення JavaScript
 * Урок 4. Теми:
 * - Пригадаємо функції
 * - Декларація змінних та функцій
 * - Глобальне і локальне
 * - Ланцюги видимости (scope chains)
 * 
 * Щоб завантажити урок у Шелл:
 * Core.Load('../../lessons/04/l-04.js');
 */

// Звикаємо завжди переходити у строгий режим:
'use strict';

Core.Print('\nLesson 4 - Start');

// 
// Пригадаємо функції
// 

// Функція - це фрагмент коду, який визначений програмістом 
// або визначений заздалегідь у реалізації JavaScript 
// (наприклад, Math.abs())

// У функції можуть передаватися параметри (аргументи) для 
// подальшої обробки даною функцією.
// Також функція може повертати значення-результат - return.

// Функції можуть зберігатися в змінних, масивах та об'єктах, 
// а також передаватися у якості аргументів інших функцій
// (тоді вони називаються callbacks - функції зворотнього виклику).

function hello() {
	Core.Print('Hello');
}

hello();

// 
// Змінні — variables
//

// Змінна - це ім'я, пов'язане зі значенням. 
// Ми говоримо, що значення зберігається, або міститься в змінній. 
// Змінні дозволяють зберігати дані і працювати з ними.

// Приклади змінних:

var aNumber = 1;
var aFunction = function() {};
var aString = 'two';
var anArray = [1, 3, 4];
var aObject = {
	a: 1,
	b: 2
};
var j = aNumber;

// 
// Variable names can contain following symbols:
// And ALWAYS start with letter:
// a-z, A-Z, _, 0-9, $
// 

// CORRECT:
var a_1 = 1;

// WRONG: (numbers can't be used as first character in variable name)
// var 1_a = 1;

// Variable names can't be reserved words of JavaScript (like type names)

// WRONG:
// var String = '';

// RIGHT:
var myString = '';


// 
// Оголошення і ініціалізація змінних
// 

// оголошення однієї змінної на рядок:
var a; // = undefined
var b; // = undefined
var c; // = undefined

var a, 
	b, 
	c;

// оголошення декількох змінних на рядок — можливе, але практично ризиковане
var b, c, e, f;

// Оголошення змінної можна поєднувати з її ініціалізацією, тобто наданням 
// їй початкового значення. Якщо початкове значення не задано в інструкції var, 
// то змінна оголошується, але її початкове значення залишається 
// невизначеним (undefined)

b = 10;

var aNumber = 100; // declaration + intialization
var birthdayDate;  // declaration only
birthdayDate = new Date();  // intialization only

// 
// Глобальні та локальні змінні
//

// Глобальні змінні — це ті, що доступні з будь-якого місця вашої програми.

// Їх використання небажане у принципі, тому що воно створює ризик конфлікту імен: 
// наприклад уявіть, що ви оголосили глобальну змінну console у браузері, 
// не підозрюючи, що в середовищі виконання таку змінну вже задано. 

// Оголосивши власну console глобально, ви знищуєте ту, що існувала до цього — 
// результат буде непередбачуваним. Що робить подібні дії вкрай ризикованими, 
// але разом з тим і дає цікаві наслідки: 
// наприклад, можна адаптувати середовище виконання до вашого коду, 
// якщо ви маєте певні особливі потреби. 

if ( console === undefined ) {
	var console = {
		log: function( str ){
			if( Core !== undefined ) {
				Core.Print( str );
			}
		},
		h1: function( str ) {
			Core.Print( '\n# ' + str + ' #\n');
		}
	};
}

console.log( 'Console.log test' );

// Shell Error: 
// TypeError: Cannot read property 'log' of undefined console.log();

// Наприклад, можна перевизначати методи глобальних об'єктів, щоб згладжувати 
// відмінності у різних середовищах 
// виконання і писати код, який буде виконуватися у різних середовищах.

// Якщо вам все ж приходиться оголошувати глобальну змінну, то дайте їй таке 
// довге і складне ім'я, яке гарантовано не перетнеться з іншим:
var myWebSiteDotCom = {};

// Приклади реальних глобальних змінних:
// $ - назва бібліотеки jQuery 
// THREE - назва 3D бібліотеки для JS (threejs.org)



// Якщо спробувати прочитати значення неоголошеної змінної, то 
// JavaScript згенерує повідомлення про помилку типу ReferenceError. 

// Якщо привласнити значення змінної, що не була оголошена за допомогою 
// інструкції var, то JavaScript неявним чином оголосить цю змінну за вас. 
// Однак змінні, оголошені таким чином, завжди створюються як глобальні, 
// навіть якщо вони працюють тільки в тілі вашої функції. 

// Тому, коли для окремої функції досить локальної змінної, завжди розміщуйте 
// інструкцію var в тілі функції, щоб не створювати зайву глобальну змінну або 
// не використовувати глобальну змінну, що вже існує. 

// Найкраще оголошувати з ключовим словом var всі змінні — і глобальні, і локальні.

// a = 1; // автоматично стрворює глобальну змінну

// 
// Область видимости (scope)
// 

// Область видимости змінної — це та частина коду, 
// для якого дана змінна є визначеною. 

// Глобальна змінна визначена для всього JavaScript коду, або файлу, 
// модуля і т.п. — тобто визначена глобально, 
// і має глобальну область видимости. 

// Змінна, оголошена усередині функції, визначена тільки в її тілі. 
// Такі змінні звуться локальними і мають локальну область видимости.

// Параметри функцій також є локальними змінними, визначеними тільки 
// в тілі цієї функції. 

// Усередині тіла функції локальна змінна має перевагу перед 
// глобальними змінними з тим же ім'ям. 

// Якщо оголосити локальну змінну або параметр функції з тим же ім'ям, 
// що і у глобальної змінної, то глобальна змінна буде фактично прихована 
// від використання у цій функції, і тільки у ній.

// Визначення функцій можуть бути вкладеними. Кожна функція має власну 
// локальну область видимости, тому може бути кілька вкладених рівнів 
// локальних областей видимости.

// Параметри функцій також є локальними змінними, 
// визначеними тільки в тілі цієї функції.

var nameGlobal = 'Global - Petro';
var nameLocal = 'Global - Larysa (2)';
var nameParam = 'Param - Taras (2)';

function helloName(nameParam) {
	// AUTO: var nameLocal; // undefined
	console.h1( 'Local Call - Before Declarations' );
	console.log( 'nameLocal = ' + nameLocal );
	console.log( 'nameGlobal = ' + nameGlobal );
	console.log( 'nameParam = ' + nameParam );

	// ця локальна змінна перекриє параметр name, 
	// але не глобальний name (не перекриє глобально):
	// var name;
	var nameLocal = 'Local - Larysa';
	// BAD BAD BAD - втручання у глобальність
	// Побічний ефект:
	nameGlobal = 'Local - Petro';  

	console.h1( 'Local Call - After Declarations' );
	console.log( 'nameLocal = ' + nameLocal );
	console.log( 'nameGlobal = ' + nameGlobal );
	console.log( 'nameParam = ' + nameParam );
}

console.h1( 'Global Call - Before Function Call' );

console.log( 'nameLocal = ' + nameLocal );
console.log( 'nameGlobal = ' + nameGlobal );
console.log( 'nameParam = ' + nameParam );

helloName( 'Taras' );

console.h1( 'Global Call - After Function Call' );
console.log( 'nameLocal = ' + nameLocal );
console.log( 'nameGlobal = ' + nameGlobal );
console.log( 'nameParam = ' + nameParam );

// 
// Перекриття глобальних змінних локальними:
// 

// Усередині тіла функції локальна змінна має перевагу перед 
// глобальними змінними з тим же ім'ям. 

// Якщо оголосити локальну змінну або параметр функції з тим же ім'ям, 
// що і у глобальної змінної, то глобальна змінна буде фактично прихована 
// від використання у цій функції, і тільки у ній.

var aGlobal = 'aGlobal from Global';

function hasLocalVarWithSameName() {
	var aGlobal = 'aGlobal from function hasLocalVarWithSameName';
	Core.Print(aGlobal);
}

hasLocalVarWithSameName();

// 
// Scope chain — ланцюг областей видимости
//

// Коли JavaScript-кодові треба знайти значення змінної x, він починає пошук 
// у першому (найбільш глибокому) об'єкті ланцюжка. 

// Якщо в цьому об'єкті є властивість з ім'ям x, 
// то використовується значення цієї властивості. 

// Якщо в першому об'єкті не вдається знайти властивість з ім'ям x, 
// то JavaScript продовжує пошук в наступному об'єкті ланцюжка. 

// Якщо у другому об'єкті теж не знайдено властивість з ім'ям x, пошук триває 
// в наступному об'єкті, і т. д.

// В JavaScript-коді верхнього рівня (в коді, не що є в одному з визначень 
// функцій), ланцюжок областей видимости складається 
// тільки з глобального об'єкту. 

// Всі змінні розшукуються в цьому об'єкті. 
// Якщо змінна не знаходиться і тут, то її значення дорівнює undefined.

var x = -1;

function onion (a0) {
	var x = 0;
	onionLayer1();
	console.log('Level 0. x = ' + x);
	function onionLayer1 (a1) {
		x = 1;
		console.log('Level 1. x = ' + x);
		onionLayer2();
		function onionLayer2 (a2) {
			var x = 2;
			console.log('Level 2. x = ' + x);
			onionLayer3();
			function onionLayer3 (a3) {
				var x = 3;
				console.log('Level 3. x = ' + x);
				console.log('Scope Chains: ');
				console.log('x = ' + x);
			}
		}
	}
}

onion();


//
// Домашня робота:
//

Core.Print('\nLesson 04 - Homework');

// Частина 1 - виконати у понеділок:

Core.Print('\nTask 4.1'); 
// (1 бал)
// Оголосіть змінні таких типів (але не ініціюйте їх):
// String, Number, Boolean, Object, Array
// TODO: пишіть свій код тут:

Core.Print('\nTask 4.2'); 
// (1 бал)
// Ініціюйте оголошені вище змінні (надайте їм початкових значень).
// TODO: пишіть свій код тут:

Core.Print('\nTask 4.3'); 
// (1 бал)
// Напишіть приклад, де змінна і оголошується, і ініціюється (одним рядком).
// TODO: пишіть свій код тут:

// Частина 2 - виконати у вівіторок:

Core.Print('\nTask 4.4'); 
// (2 бали)
// Дайте відповідь, чи правдиві наступні твердження, надаючи значеннь
// true чи false відповідним змінним:

// a) Твердження: "У JavaScript існує окремий тип даних Float."
// TODO: надайте значення false чи true цій змінній:
var floatExistsInJs; 

// b) Твердження: "У JavaScript існує окремий тип даних Char." 
// TODO: надайте значення false чи true цій змінній:
var charExistsInJs;

// c) Твердження: "У JavaScript існує окремий тип даних Number."
// TODO: надайте значення false чи true цій змінній:
var numberExistsInJs;

Core.Print('\nTask 4.5'); 
// (1 бал) 

// Продовжимо роботу над студентом:

var student = {
	name: 'Petro',
	surname: 'Tymoshenko',
	email: 'p@igov.org.ua',
	address: 'Kyiv',
	birthdayDate: new Date(1986, 8, 24),
	getInfo: function() {
		return this.name + ' ' + this.surname + ' ' + this.adress + ' ' + this.birthdayDate.toDateString();
	}
};

// Додайте до визначеного вище об'єкта student властивість 
// homeworkFolder — шлях до каталогу з файлами і виведіть результат у консоль.

// TODO: пишіть свій код тут:

// Частина 3 - Середа:

Core.Print('\nTask 4.6');
// (2 бали) 
// Додайте до student-а метод getHomeworkFileById, який приймає три параметри: 
// fileName, fileExtension та lessonId
// і повертає результат їх поєднання з властивістю homeworkFolder з попереднього завдання таким чином, 
// щоб утворився зрозумілий шлях до файлу типу: '../../lessons/04/l-04.js'

// TODO: пишіть свій код тут:

Core.Print('\nTask 4.7'); 
// (3 бали)
// Спробуйте самотужки створити ієрархію з двох вкладених функцій doTheJob та thinkBeforeDoing таким чином, 
// щоб обидві функції мали по власній змінній result, значення якої буде різним 
// у різних областях видимости (функціях) і буде виводитися на консоль.

// TODO: пишіть свій код тут:

// Частина 4 - субота і неділя:

Core.Print('\nTask 4.8');
// Почитати на вихідних:

// Субота:
// http://wiki.kspu.kr.ua/index.php/%D0%97%D0%BC%D1%96%D0%BD%D0%BD%D1%96_%D1%82%D0%B0_%D1%82%D0%B8%D0%BF%D0%B8_%D0%B4%D0%B0%D0%BD%D0%BD%D0%B8%D1%85_%D0%B2_JavaScript

// Неділя:
// https://learn.javascript.ru/function-basics

Core.Print('\nLesson 04 - Homework End');